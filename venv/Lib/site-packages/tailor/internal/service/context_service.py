# -*- coding: utf-8 -*-
from typing import List, Optional, Any

import yaql

from tailor.internal.domain.context.context_model import ContextModel
from tailor.internal.domain.context.context_repository import ContextRepository
from tailor.internal.service.storage_service import StorageService


class ContextService:

    def __init__(self, project_name: str = None):
        self.repository: ContextRepository = ContextRepository(project_name)
        self.engine = yaql.factory.YaqlFactory().create()
        self.storage_service: StorageService = StorageService(project_name)

    def insert(self, context: ContextModel):
        return self.repository.insert(context)

    def insert_many(self, contexts: List[ContextModel]):
        return self.repository.insert_many(contexts)

    def replace(self, context: ContextModel) -> ContextModel:
        context_dict = self.repository.replace(context)
        return ContextModel.from_dict(context_dict)

    def find_by_id(self, context_id) -> ContextModel:
        context_dict = self.repository.find_by_id(context_id)
        if context_dict:
            return ContextModel.from_dict(context_dict)
        else:
            return None

    def refresh(self, context: ContextModel) -> ContextModel:
        context_dict = self.repository.refresh(context)
        return ContextModel.from_dict(context_dict)

    def create(self, inputs: dict, outputs: dict, storage_key) -> ContextModel:
        return self.repository.create(inputs, outputs, storage_key)

    def query(self, context: ContextModel,
              expression: str,
              scope_indices: Optional[List[int]] = None) -> Any:

        datatype = expression.split('.')[1]
        # inputs, outputs or storage

        # build scoped tag: filename(s) dict
        storage = {}
        for tag in self.storage_service.get_tags(context.storage_key):

            # get filenames
            fnames = self.storage_service.get_prefixed_file_list(
                context.storage_key,
                tag,
                scope_indices or [])

            if len(fnames) == 1:
                storage[tag] = fnames[0]
            else:
                storage[tag] = fnames

        data = {
            'inputs': context.inputs,
            'outputs': context.outputs,
            'storage': storage
        }

        if datatype == 'inputs':
            return self.engine(expression).evaluate(data=data)

        elif datatype == 'outputs':
            # TODO: need to get down to correct dup level before query is
            # evaluated to have generic YAQL expression support inside duplicates
            # Now we only assume and support a simple name reference for nested
            # contexts
            res = self.engine(expression).evaluate(data=data)
            if scope_indices:
                name = expression.split('.')[-1]
                output_dict_id = [name]
                for dup_index in scope_indices:
                    if output_dict_id not in context.output_dict_ids:
                        return res
                    res = res[dup_index]
                    output_dict_id = output_dict_id + [dup_index]
            return res

        elif datatype == 'storage':
            # TODO: address duplication level here as well
            return self.engine(expression).evaluate(data=data)

        else:
            raise ValueError('queries must start with "$.inputs", "$.outputs"'
                             ' or "$.storage"')

    def add_output(self, context: ContextModel, name: str, data,
                   scope_indices: Optional[List[int]] = None):
        # add at correct "duplication level"
        # output_dict_id is a unique id that indicates where in the
        # duplication hierarchy the output was added/created. This is used
        # later to correctly "scope" the output when referenced

        if scope_indices:
            output_dict_id = [name]
            dup_dict = context.outputs.get(name)
            if output_dict_id not in context.output_dict_ids:
                dup_dict = context.outputs[name] = {}
                context.output_dict_ids.append(output_dict_id)

            if len(scope_indices) > 1:
                for dup_index in scope_indices[:-1]:
                    output_dict_id = output_dict_id + [dup_index]
                    if output_dict_id not in context.output_dict_ids:
                        dup_dict[dup_index] = {}
                        context.output_dict_ids.append(output_dict_id)
                    dup_dict = dup_dict[dup_index]

            dup_dict[scope_indices[-1]] = data
        else:
            context.outputs[name] = data

    def delete_by_id(self, context_id):
        return self.repository.delete_by_id(context_id)
