# -*- coding: utf-8 -*-


from typing import List

from tailor.internal.domain.run import RunModel
from tailor.internal.domain.run import RunRepository
from tailor.internal.domain.single_task import SingleTaskModel
from tailor.internal.domain.single_task import SingleTaskState


class RunService:

    def __init__(self, project_name: str = None):
        self.repository: RunRepository = RunRepository(project_name)

    def insert(self, run: RunModel):
        return self.repository.insert(run)

    def insert_many(self, runs: List[RunModel]):
        return self.repository.insert_many(runs)

    def replace(self, run: RunModel) -> RunModel:
        run_dict = self.repository.replace(run)
        return RunModel.from_dict(run_dict)

    def find_by_id(self, run_id) -> RunModel:
        run_dict = self.repository.find_by_id(run_id)
        return RunModel.from_dict(run_dict)

    def delete_by_task_id(self, task_id):
        self.repository.delete_by_task_id(task_id)

    def find_by_task_id(self, task_id, allowed_projects=None) -> List[RunModel]:
        run_dicts = self.repository.find_by_task_id(task_id)
        runs = [RunModel.from_dict(x) for x in run_dicts]
        return runs

    def create(self, task_id, rundir) -> RunModel:
        return self.repository.create(task_id, rundir)

    def update_state(self, run_id, state, error_message: str = None,
                     traceback: str = None) -> RunModel:
        run = self.find_by_id(run_id)
        run.state = state
        if error_message:
            run.error_message = error_message
        if traceback:
            run.traceback = traceback
        return self.replace(run)

    def get_representative_run(self, task: SingleTaskModel):
        max_score = SingleTaskState.ARCHIVED.value
        run = None
        runs = self.find_by_task_id(task.id)
        completed_runs = []
        for r in runs:
            if r.state.value > max_score:
                max_score = r.state.value
                run = r
                if r.state == SingleTaskState.COMPLETED:
                    completed_runs.append(r)
        if completed_runs:
            return max(completed_runs, key=lambda v: v.time_end)
        return run
