# -*- coding: utf-8 -*-


from typing import List

from tailor.internal.domain.single_task import SingleTaskModel
from tailor.internal.domain.single_task import SingleTaskRepository
from tailor.internal.domain.single_task import SingleTaskState
from tailor.internal.service.run_service import RunService


class SingleTaskService:

    def __init__(self, project_name: str = None):
        self.repository: SingleTaskRepository = SingleTaskRepository(project_name)
        self.run_service: RunService = RunService(project_name)

    def insert(self, task: SingleTaskModel):
        return self.repository.insert(task)

    def insert_many(self, tasks: List[SingleTaskModel]):
        return self.repository.insert_many(tasks)

    def replace(self, task: SingleTaskModel) -> SingleTaskModel:
        task_dict = self.repository.replace(task)
        return SingleTaskModel.from_dict(task_dict)

    def find_by_id(self, task_id, allowed_projects=None) -> SingleTaskModel:
        task_dict = self.repository.find_by_id(task_id)
        return SingleTaskModel.from_dict(task_dict)

    def get_workflow_id(self, task_id):
        return self.repository.get_workflow_id(task_id)

    def find_by_workflow_id(self, wf_id, allowed_projects=None) -> List[
        SingleTaskModel]:
        task_dicts = self.repository.find_by_workflow_id(wf_id)
        if task_dicts:
            return [SingleTaskModel.from_dict(task_dict) for task_dict in task_dicts]
        else:
            return None

    def create_tasks_and_links(self, wf_id, task_defs, p_c_links, worker,
                               scope_indices=None) -> (List[SingleTaskModel], dict):
        return self.repository.create_tasks_and_links(wf_id, task_defs, p_c_links,
                                                      worker, scope_indices)

    def checkout_ready_task(self, worker=None, wf_id=None) -> SingleTaskModel:
        query = {'state': SingleTaskState.READY.name}

        # add worker to query
        worker_check = [{'worker': {'$exists': False}},
                        {'worker': None}]
        if worker is not None:
            worker_check.append({'worker': worker})
        query['$or'] = worker_check

        # add wf_id to query
        if wf_id:
            query['wf_id'] = wf_id

        task_dict = self.repository.update_one(query)

        if not task_dict:
            return

        # get runs
        runs = self.run_service.find_by_task_id(task_dict['id'])
        task_dict['runs'] = [run.to_dict() for run in runs]

        # task is currently RESERVED, its up to the caller to start running
        # the task, put it in a queue, or un-reserve the task if something goes
        # wrong before it starts to run.
        # This Task can e.g. be passed to a TaskRunner.
        return SingleTaskModel.from_dict(task_dict)
        # ALT: return self.get_task_by_id(task_dict['id'])

    def delete_by_id(self, task_id):
        self.repository.delete_by_id(task_id)

    def delete_by_workflow_id(self, task_id):
        self.repository.delete_by_workflow_id(task_id)

    def reset_task(self, task_id: int) -> None:
        self.repository.reset_task(task_id)
