# -*- coding: utf-8 -*-
import random
import time

from tailor.exceptions import LockedDocumentError


class DocumentLock:
    """
    Lock a Document for performing update operations
    Raises a LockedDocumentError if the lock couldn't be acquired withing
    expire_secs and kill==False. Calling functions are responsible for handling
    the error in order to avoid database inconsistencies.
    """

    def __init__(self, coll, doc_id, expire_secs=60 * 5, kill=False):
        """
        Args:
            coll (A MongoDB collection)
            doc_id (int): Assumes that the document has an 'id' field
            expire_secs (int): max waiting time in seconds.
            kill (bool): force lock acquisition or not after expire_secs
        """
        self.coll = coll
        self.doc_id = doc_id
        self.expire_secs = expire_secs
        self.kill = kill

    def __enter__(self):
        ctr = 0
        waiting_time = 0
        # acquire lock
        doc_dict = self.coll.find_one_and_update({'id': self.doc_id,
                                                  'locked': {
                                                      '$exists': False}},
                                                 {'$set': {
                                                     'locked': True}})
        # could not acquire lock, workflow is already locked for writing
        while not doc_dict:
            print(f'\nwaiting for lock: {self.coll.name}, id: {self.doc_id}\n')
            ctr += 1
            time_incr = ctr / 10.0 + random.random() / 100.0
            time.sleep(time_incr)  # wait a bit for lock to free up
            waiting_time += time_incr
            if waiting_time > self.expire_secs:  # too much time waiting, expire lock
                if self.kill:  # force lock acquisition
                    doc_dict = self.coll.find_one_and_update(
                        {'id': self.doc_id},
                        {'$set': {'locked': True}})
                else:  # throw error if we don't want to force lock acquisition
                    raise LockedDocumentError(
                        f'Could not get workflow with id {self.doc_id} because it is locked')
            else:
                # retry lock
                doc_dict = self.coll.find_one_and_update(
                    {'id': self.doc_id, 'locked': {"$exists": False}},
                    {'$set': {'locked': True}})

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.coll.find_one_and_update({'id': self.doc_id},
                                      {"$unset": {"locked": True}})
