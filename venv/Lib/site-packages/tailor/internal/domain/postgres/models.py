"""
Tables and relationships for SQLAlchemy ORM are centralized to this file,
in order to avoid circular import errors for classes that have a many to many
relationship, e.g. ProjectDao and UserDao.
"""
import enum
from typing import List

from sqlalchemy import Column, Table, Integer, ForeignKey, String, UniqueConstraint, \
    JSON, Enum
from sqlalchemy.orm import relationship

from tailor.internal.domain.postgres import AlchemyBase

account_memberships = Table('account_memberships', AlchemyBase.metadata,
                            Column('account_id', Integer, ForeignKey('accounts.id')),
                            Column('user_id', Integer, ForeignKey('users.id'))
                            )

allowed_projects = Table('allowed_projects', AlchemyBase.metadata,
                         Column('project_id', Integer, ForeignKey('projects.id')),
                         Column('user_id', Integer, ForeignKey('users.id'))
                         )

task_definition_subscriptions = Table('task_definition_subscriptions',
                                      AlchemyBase.metadata,
                                      Column('project_id', Integer,
                                             ForeignKey('projects.id')),
                                      Column('task_definition_id', Integer,
                                             ForeignKey('task_definitions.id'))
                                      )


# This table represents a customer
class AccountDao(AlchemyBase):
    __tablename__ = 'accounts'
    __table_args__ = (
        UniqueConstraint('organization_name', 'organization_id',
                         name='unique_company'),)

    id = Column(Integer, primary_key=True)
    uuid = Column(String, nullable=False, unique=True)
    organization_name = Column(String, nullable=False)
    organization_id = Column(String, nullable=False)  # National registration number

    users = relationship("UserDao",
                         secondary=account_memberships,
                         back_populates="accounts")
    projects = relationship("ProjectDao", back_populates="account")
    task_definitions = relationship("TaskDefinitionDao",
                                    back_populates="account")

    feature_plan_id = Column(Integer, ForeignKey('feature_plans.id'))
    feature_plan = relationship("FeaturePlanDao", back_populates="accounts")

    def __repr__(self):
        return f'Company {self.organization_name} ({id})'

    def __eq__(self, other):
        if isinstance(other, AccountDao):
            return self.id == other.id
        return False


class UserIdProvider(enum.Enum):
    COGNITO_TAILOR = "Tailor Cognito user pool"
    LOCAL_CONFIG_FILE = "Local configuration file"


class StorageType(enum.Enum):
    AZURE_BLOB_CONTAINER = "AZURE_BLOB_CONTAINER"
    LOCAL_FILESYSTEM = "LOCAL_FILESYSTEM"
    S3_BUCKET = "S3_BUCKET"


class WorkflowDbType(enum.Enum):
    MONGODB_COMPAT = "MongoDB and compatibles"


class ProjectDao(AlchemyBase):
    __tablename__ = 'projects'

    id = Column(Integer, primary_key=True)
    name = Column(String, nullable=False)
    uuid = Column(String, nullable=False, unique=True)
    # s3, Azure or file
    storage_type = Column(Enum(StorageType), nullable=False)
    # bucket name, file path, and equivalent
    storage_identifier = Column(String, nullable=False)
    external_reference = Column(String)  # a reference to a project ID in another system

    users = relationship("UserDao",
                         secondary=allowed_projects,
                         back_populates="projects")

    account_id = Column(Integer, ForeignKey('accounts.id'), nullable=False)
    account = relationship("AccountDao", back_populates="projects")

    task_definitions = relationship("TaskDefinitionDao",
                                    secondary=task_definition_subscriptions,
                                    back_populates="projects")

    def __repr__(self):
        return f'Project {self.name} ({id})'

    def __eq__(self, other):
        if isinstance(other, ProjectDao):
            return self.id == other.id
        return False


class UserDao(AlchemyBase):
    __tablename__ = 'users'
    __table_args__ = (UniqueConstraint('username', 'id_provider',
                                       name='unique_username_from_provider'),)
    id = Column(Integer, primary_key=True)
    username = Column(String, nullable=False)
    id_provider = Column(Enum(UserIdProvider), nullable=False,
                         default=UserIdProvider.COGNITO_TAILOR)
    uuid = Column(String, nullable=False, unique=True)

    accounts: List[AccountDao] = relationship(
        "AccountDao",
        secondary=account_memberships,
        back_populates="users")
    projects: List[ProjectDao] = relationship(
        "ProjectDao",
        secondary=allowed_projects,
        back_populates="users")

    def __repr__(self):
        return f'User {self.username} ({id})'

    def __eq__(self, other):
        if isinstance(other, UserDao):
            return self.id == other.id
        return False


class FeatureDao(AlchemyBase):
    __tablename__ = 'features'

    id = Column(Integer, primary_key=True)
    name = Column(String, nullable=False)
    feature_plan_id = Column(Integer, ForeignKey('feature_plans.id'))
    feature_plan = relationship("FeaturePlanDao", back_populates="features")

    def __repr__(self):
        return f'Feature {self.name} ({id})'

    def __eq__(self, other):
        if isinstance(other, FeatureDao):
            return self.id == other.id
        return False


class FeaturePlanDao(AlchemyBase):
    __tablename__ = 'feature_plans'

    id = Column(Integer, primary_key=True)
    name = Column(String, nullable=False)
    accounts = relationship("AccountDao", back_populates="feature_plan")
    features = relationship("FeatureDao", back_populates="feature_plan")

    def __repr__(self):
        return f'FeaturePlan {self.name} ({id})'

    def __eq__(self, other):
        if isinstance(other, FeaturePlanDao):
            return self.id == other.id
        return False


class TaskDefinitionDao(AlchemyBase):
    __tablename__ = 'task_definitions'

    id = Column(Integer, primary_key=True)
    name = Column(String, nullable=False, unique=True)
    # JSON-field requires SQLite version 3.9 or later, Postgres 12.0 or later
    json_definition = Column(JSON, nullable=False)
    schema_version = Column(Integer, default=1)

    account_id = Column(Integer, ForeignKey('accounts.id'))
    account = relationship("AccountDao", back_populates="task_definitions")

    projects = relationship(
        "ProjectDao",
        secondary=task_definition_subscriptions,
        back_populates="task_definitions")

    def __repr__(self):
        return f'TaskDefinition {self.name} ({id})'

    def __eq__(self, other):
        if isinstance(other, TaskDefinitionDao):
            return self.id == other.id
        return False
