# -*- coding: utf-8 -*-
from typing import List

from pymongo.results import InsertOneResult, InsertManyResult, DeleteResult

from tailor.exceptions import LockedDocumentError, DatabaseError
from tailor.internal.domain.mongo import BaseRepository, DocumentLock
from tailor.internal.domain.context import ContextModel


class ContextRepository(BaseRepository):

    def __init__(self, project: str = None):
        super().__init__(project)
        self._contexts = self._client.contexts

    def insert(self, context: ContextModel):
        result: InsertOneResult = self._contexts.insert_one(context.to_dict())
        if not result.acknowledged:
            raise DatabaseError("Could not insert new Context into db")

    def insert_many(self, runs: List[ContextModel]):
        dicts = [dbt.to_dict() for dbt in runs]
        result: InsertManyResult = self._contexts.insert_many(dicts)
        if not result.acknowledged:
            raise DatabaseError("Could not insert new Contexts into db")

    def replace(self, context: ContextModel, preserve_lock=False) -> dict:
        context_dict = context.to_dict()
        if preserve_lock:
            context_dict['locked'] = True
        updated_object = self._contexts.find_one_and_replace({'id': context.id},
                                                             context_dict)
        return updated_object

    def find_by_id(self, context_id) -> dict:
        context_dict = self._contexts.find_one({'id': context_id})
        return context_dict

    def create(self, inputs: dict, outputs: dict, storage_key) -> ContextModel:
        # create a new Context and add it to the database, return it
        context_id = self._get_new_id(id_type='context')
        context = ContextModel(context_id, inputs, outputs, storage_key)
        self.insert(context)
        return context

    def lock_manager(self, context_id):
        return DocumentLock(self._contexts, context_id)

    def refresh(self, updated_context: ContextModel) -> dict:
        # Adds the outputs, output_dict_ids and tags_prefixes
        # in the given updated_context to the latest version of the Context object
        # in the database.
        try:
            with self.lock_manager(updated_context.id):
                db_context_dict = self.find_by_id(updated_context.id)
                merged_context: ContextModel = ContextModel.from_dict(db_context_dict)

                # outputs
                merged_context.update_nested_dict(merged_context.outputs,
                                                  updated_context.outputs)

                # output_dict_ids
                for od_id in updated_context.output_dict_ids:
                    if od_id not in merged_context.output_dict_ids:
                        merged_context.output_dict_ids.append(od_id)

                return self.replace(merged_context, preserve_lock=True)
        except LockedDocumentError:
            # do something
            raise

    def delete_by_id(self, context_id):
        result: DeleteResult = self._contexts.delete_one({'id': context_id})
        if not result.acknowledged:
            raise DatabaseError(f"Could not delete Context with id {context_id}")
