# -*- coding: utf-8 -*-

from datetime import datetime
from enum import Enum

from tailor.internal.domain.mongo import BaseModel


class SingleTaskState(Enum):
    ARCHIVED = -2
    FAILED = -1
    STOPPED = 0
    WAITING = 1
    READY = 2
    RESERVED = 3
    RUNNING = 4
    COMPLETED = 5

    @classmethod
    def to_dict(cls, task_states: dict) -> dict:
        return {str(k): v.name for k, v in task_states.items()}

    @classmethod
    def from_dict(cls, task_states: dict) -> dict:
        return {int(k): SingleTaskState[v] for k, v in task_states.items()}


class SingleTaskModel(BaseModel):
    def __init__(self, task_id, wf_id, task_def, worker=None, state=SingleTaskState.WAITING,
                 created_on=None, updated_on=None, run_ids=None, scope_indices=None):

        # should tasks belong to groups according to their original workflow
        # affiliation? relevant if nested workflow. this could be useful for
        # visualization etc. where tasks can be grouped according to their
        # original sub-workflow. tasks can then belong to several groups,
        # depending on nesting level

        self.id = task_id
        self.wf_id = wf_id
        self.task_def = task_def
        self.worker = worker
        self._state = state
        self.created_on = created_on or datetime.utcnow()
        self.updated_on = updated_on or datetime.utcnow()
        self.run_ids = run_ids or []
        self.scope_indices = scope_indices or []

    @property
    def state(self):
        return self._state

    @state.setter
    def state(self, state):
        self._state = state
        self.updated_on = datetime.utcnow()

    def to_dict(self):
        return {
            'id': self.id,
            'wf_id': self.wf_id,
            'task_def': self.dict_keys_int_to_str(self.task_def),
            'worker': self.worker,
            'state': self.state.name,
            'run_ids': self.run_ids,
            'created_on': self.created_on,
            'updated_on': self.updated_on,
            'scope_indices': self.scope_indices
        }

    @classmethod
    def from_dict(cls, d):
        return SingleTaskModel(
            task_id=d['id'],
            wf_id=d['wf_id'],
            task_def=BaseModel.dict_keys_str_to_int(d['task_def']),
            worker=d['worker'],
            state=SingleTaskState[d['state']],
            run_ids=d['run_ids'],
            created_on=d['created_on'],
            updated_on=d['updated_on'],
            scope_indices=d['scope_indices']
        )
