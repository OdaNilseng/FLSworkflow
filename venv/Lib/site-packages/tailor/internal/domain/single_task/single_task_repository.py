# -*- coding: utf-8 -*-
from datetime import datetime
from typing import List

from pymongo import DESCENDING, ASCENDING, ReturnDocument
from pymongo.results import InsertOneResult, InsertManyResult, DeleteResult

from tailor.exceptions import DatabaseError
from tailor.internal.domain.mongo import BaseRepository
from .single_task_model import SingleTaskModel, SingleTaskState


class SingleTaskRepository(BaseRepository):

    def __init__(self, project: str):
        super().__init__(project)
        self._tasks = self._client.tasks

    def insert(self, task: SingleTaskModel):
        result: InsertOneResult = self._tasks.insert_one(task.to_dict())
        if not result.acknowledged:
            raise DatabaseError("Could not insert new Task into db")

    def insert_many(self, tasks: List[SingleTaskModel]):
        task_dicts = [dbt.to_dict() for dbt in tasks]
        result: InsertManyResult = self._tasks.insert_many(task_dicts)
        if not result.acknowledged:
            raise DatabaseError("Could not insert new Tasks into db")

    def replace(self, task: SingleTaskModel) -> dict:
        return self._tasks.find_one_and_replace({'id': task.id}, task.to_dict())

    def find_by_id(self, task_id) -> dict:
        task_dict = self._tasks.find_one({'id': task_id})
        return task_dict

    def get_workflow_id(self, task_id):
        return self._tasks.find_one({'id': task_id}, ['wf_id'])['wf_id']

    def update_one(self, query) -> dict:
        # sort first by priority, then FIFO
        sortby = [('priority', DESCENDING), ('created_on', ASCENDING)]

        task_dict = self._tasks.find_one_and_update(
            query,
            {'$set': {
                'state': SingleTaskState.RESERVED.name,
                'updated_on': datetime.utcnow()}},
            sort=sortby,
            return_document=ReturnDocument.AFTER
        )
        return task_dict

    def find_by_workflow_id(self, wf_id) -> List[dict]:
        return self._tasks.find({'wf_id': wf_id})

    def create_tasks_and_links(self, wf_id, task_defs, p_c_links, worker,
                               scope_indices=None) -> (List[SingleTaskModel], dict):
        # get ids for tasks and create Task/id map
        task_id1 = self._get_new_id('task', quantity=len(task_defs))
        task_ids = list(range(task_id1, task_id1 + len(task_defs)))
        task_id_map = {t: t_id for (t, t_id) in zip(task_defs, task_ids)}

        # Create Task objects from scratch
        tasks = []
        for td, t_id in zip(task_defs, task_ids):
            tasks.append(
                SingleTaskModel(
                    task_id=t_id,
                    wf_id=wf_id,
                    task_def=td.to_dict(),
                    worker=worker,
                    scope_indices=scope_indices
                )
            )

        # create links based on task ids
        p_c_links = {
            task_id_map[p]: [task_id_map[ci] for ci in c]
            for (p, c) in p_c_links.items()}

        return tasks, p_c_links

    def delete_by_id(self, task_id):
        result: DeleteResult = self._tasks.delete_one({'id': task_id})
        if not result.acknowledged:
            raise DatabaseError(f"Could not delete Task with id {task_id}")

    def delete_by_workflow_id(self, wf_id):
        result: DeleteResult = self._tasks.delete_many({'wf_id': wf_id})
        if not result.acknowledged:
            raise DatabaseError(f"Could not delete Tasks with wf_id {wf_id}")

    def reset_task(self, task_id: int) -> None:
        self._tasks.find_one_and_update(
            {'id': task_id},
            {'$set': {
                'state': SingleTaskState.READY.name,
                'updated_on': datetime.utcnow()}},
        )
