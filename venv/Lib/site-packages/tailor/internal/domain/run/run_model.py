# -*- coding: utf-8 -*-
from datetime import datetime
from pathlib import Path
from typing import List

from tailor.internal.domain.mongo import BaseModel
from tailor.internal.domain.single_task import SingleTaskState


class RunModel(BaseModel):

    def __init__(self, run_id, task_id, rundir, state=SingleTaskState.RUNNING,
                 state_history=None, traceback=None, error_message=None):
        self.id = run_id
        self.task_id = task_id
        self.rundir = Path(rundir)
        self._state = state
        self.state_history = state_history if state_history else []
        self._traceback = traceback
        self._error_message = error_message

    @property
    def state(self):
        return self._state

    @state.setter
    def state(self, state):
        self._state = state
        self._update_state_history(state)

    @property
    def error_message(self):
        return self._error_message

    @error_message.setter
    def error_message(self, error_message):
        self._error_message = error_message

    @property
    def traceback(self):
        return self._traceback

    @traceback.setter
    def traceback(self, traceback):
        self._traceback = traceback

    @property
    def time_end(self):
        return self._get_time([SingleTaskState.COMPLETED, SingleTaskState.FAILED])

    def _update_state_history(self, state):
        if len(self.state_history) > 0:
            last_state = self.state_history[-1]['state']
        else:
            last_state = None
        if state != last_state:
            now_time = datetime.utcnow()
            new_history_entry = {'state': state.name, 'created_on': now_time}
            self.state_history.append(new_history_entry)

    def _get_time(self, states: List[SingleTaskState], use_update_time=False):
        state_names = [state.name for state in states]
        for data in self.state_history:
            if data['state'] in state_names:
                if use_update_time:
                    return data['updated_on']
                return data['created_on']
        return None

    def to_dict(self):
        d = {
            'id': self.id,
            'task_id': self.task_id,
            'rundir': str(self.rundir.absolute()),
            'state': self.state.name,
            'state_history': self.state_history,
        }
        if self.traceback:
            d['traceback'] = self.traceback
        if self.error_message:
            d['error_message'] = self.error_message
        return d

    @classmethod
    def from_dict(cls, d):
        return RunModel(
            run_id=d['id'],
            task_id=d['task_id'],
            rundir=d['rundir'],
            state=SingleTaskState[d['state']],
            state_history=d.get('state_history'),
            traceback=d.get('traceback'),
            error_message=d.get('error_message')
        )
