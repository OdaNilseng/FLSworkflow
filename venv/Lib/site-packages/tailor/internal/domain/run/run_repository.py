# -*- coding: utf-8 -*-
from typing import List

from pymongo.results import InsertManyResult, InsertOneResult, DeleteResult

from tailor.exceptions import DatabaseError
from tailor.internal.domain.mongo import BaseRepository
from . import RunModel


class RunRepository(BaseRepository):

    def __init__(self, project: str):
        super().__init__(project)
        self._runs = self._client.runs  # a task can be run several times, i.e. on failure

    def insert(self, run: RunModel):
        result: InsertOneResult = self._runs.insert_one(run.to_dict())
        if not result.acknowledged:
            raise DatabaseError("Could not insert new Run into db")

    def insert_many(self, runs: List[RunModel]):
        dicts = [dbt.to_dict() for dbt in runs]
        result: InsertManyResult = self._runs.insert_many(dicts)
        if not result.acknowledged:
            raise DatabaseError("Could not insert new Runs into db")

    def replace(self, run: RunModel) -> dict:
        return self._runs.find_one_and_replace({'id': run.id}, run.to_dict())

    def find_by_id(self, run_id) -> dict:
        run_dict = self._runs.find_one({'id': run_id})
        return run_dict

    def create(self, task_id, rundir) -> RunModel:
        # create a new Run and add it to the database, return it
        run_id = self._get_new_id(id_type='run')
        run = RunModel(run_id, task_id, rundir)
        self.insert(run)
        return run

    def find_by_task_id(self, task_id) -> List[dict]:
        run_dicts = self._runs.find({'task_id': task_id})
        return run_dicts

    def delete_by_task_id(self, task_id):
        result: DeleteResult = self._runs.delete_many({'task_id': task_id})
        if not result.acknowledged:
            raise DatabaseError(f"Could not delete Runs by task_id {task_id}")
