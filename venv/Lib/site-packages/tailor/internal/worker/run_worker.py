# -*- coding: utf-8 -*-

import argparse
import asyncio
import concurrent.futures
import logging
import platform
import uuid
from multiprocessing import cpu_count

from tailor.config import LOGGING_FORMAT
from tailor.internal.execution.taskrunner import run_task
# non-blocking task executor
from tailor.internal.service import SingleTaskService
from tailor.internal.utils import get_logger, get_default_project


async def async_run_task(pool, project_name, task):
    loop = asyncio.get_running_loop()
    result = await loop.run_in_executor(pool, run_task, project_name, task)
    return result


# task run-manager
async def run_manager(project_name, worker, ncores, sleep):
    # use default project if not provided
    if project_name is None:
        project_name = get_default_project()

    # set up logging
    core_report_format = LOGGING_FORMAT + f' (%(n)s/{ncores} cores in use, ' + 'prj: %(prj)s)'
    formatter = logging.Formatter(core_report_format)
    logger = get_logger(f'{project_name}', formatter=formatter)
    nrunning = 0
    extra = {'n': nrunning, 'prj': project_name}
    logger = logging.LoggerAdapter(logger, extra)

    single_task_service = SingleTaskService(project_name)

    # helper to handle finished asyncio_tasks
    def handle_finished(aio_tasks):
        for aio_task in list(aio_tasks):
            if aio_task.done():
                aio_tasks.remove(aio_task)
                print('Task finished', aio_task.result())

    # go into loop with process pool
    with concurrent.futures.ProcessPoolExecutor(max_workers=ncores) as pool:
        try:
            asyncio_tasks = set()
            while True:
                nrunning = len(asyncio_tasks)
                extra['n'] = nrunning  # update running for logging
                if nrunning < ncores:
                    # look for READY task
                    single_task = single_task_service.checkout_ready_task(worker=worker)
                    if single_task:
                        logger.info(f'Job available, starting run for task {single_task.id}')
                        asyncio_task = asyncio.create_task(async_run_task(
                            pool, project_name, single_task))
                        asyncio_tasks.add(asyncio_task)
                        # use a shorter fixed sleep time here in order to start
                        # jobs faster when many are available
                        await asyncio.sleep(.3)
                        handle_finished(asyncio_tasks)
                    else:
                        logger.info(f'No jobs available, waiting {sleep} seconds')
                        await asyncio.sleep(sleep)
                        handle_finished(asyncio_tasks)
                else:
                    logger.info(f'All cores in use, waiting {sleep} seconds')
                    await asyncio.sleep(sleep)
                    handle_finished(asyncio_tasks)

        except asyncio.CancelledError:
            pass  # TODO recover or die?
            # print('\excepted CanceledError\n')


def default_worker_name():
    machine_id = hex(uuid.getnode())[2:-4]
    short_hostname = platform.node().split('.', 1)[0]
    return f'{short_hostname}_{machine_id}'


# script entry point
def main():
    parser = argparse.ArgumentParser(
        description='Multi-platform parallel processing for Tailor')
    parser.add_argument('--sleep', default=3,
                        help='sleep time between each job pulling requests (secs)')
    parser.add_argument('--ncores', default=cpu_count() - 1,
                        help='max number of parallel jobs')
    parser.add_argument('--workername', default=default_worker_name(),
                        metavar='WORKERNAME',
                        help='Provide a worker name')
    parser.add_argument('--project', metavar='PROJECTNAME',
                        help='Provide a project name')

    args = parser.parse_args()
    try:
        asyncio.run(run_manager(args.project,
                                args.workername,
                                int(args.ncores),
                                int(args.sleep))
                    )
    except KeyboardInterrupt:
        print("CTRL-C pressed, exiting...")


if __name__ == '__main__':
    main()
