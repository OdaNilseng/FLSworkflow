# -*- coding: utf-8 -*-
from abc import abstractmethod
from pathlib import PurePath
from typing import Optional, List, Union, Sequence


class StorageProvider:

    @staticmethod
    def _get_target_dir(scope_prefix, scope_indices):
        p = PurePath(scope_prefix)
        tag = str(list(p.parents)[-2])
        indices = [int(i) for i in p.parts[1:]]

        if len(indices) <= len(scope_indices):
            # downloading from a lower dup level
            return '.'
        else:
            # downloading from a higher dup level
            target_indices = indices.copy()
            for i in range(len(scope_indices)):
                if indices[i] == scope_indices[i]:
                    target_indices.pop(0)
                else:
                    break

            target_dir = tag
            for index in target_indices:
                target_dir += '/' + str(index)
            return target_dir

    @staticmethod
    def _get_filename_prefix(scope_prefix, scope_indices):
        p = PurePath(scope_prefix)
        indices = [int(i) for i in p.parts[1:]]

        if len(indices) <= len(scope_indices):
            # downloading from a lower dup level
            return ''
        else:
            # downloading from a higher dup level
            target_indices = indices.copy()
            for i in range(len(scope_indices)):
                if indices[i] == scope_indices[i]:
                    target_indices.pop(0)
                else:
                    break

            filename_prefix = ''
            for index in target_indices:
                filename_prefix += str(index) + '_'
            return filename_prefix

    @abstractmethod
    def _add_tag(self, storage_key, tag, paths):
        return NotImplemented

    @abstractmethod
    def _load_tags(self, storage_key):
        return NotImplemented

    @abstractmethod
    def _add_scope_prefix(self, storage_key, scope_prefix):
        return NotImplemented

    @abstractmethod
    def _load_scope_prefixes(self, storage_key):
        return NotImplemented

    @abstractmethod
    def new_storage_key(self) -> str:
        """
        Create a new storage key.

        Returns
        -------
        str
            A Unique identifier for a file storage location.
        """
        return NotImplemented

    @abstractmethod
    def get_tags(self, storage_key: str) -> dict:
        """Get tag/filename(s) mapping"""
        return NotImplemented

    def get_file_list(self, storage_key: str, name_filter: str = '*') -> List[str]:
        """
        Get file names stored in this storage key.

        Parameters
        ----------
        storage_key : str
            Unique identifier for a file storage location.
        name_filter : str, optional
            Provide a glob-style filter. The default is '*'.

        Returns
        -------
        List[str]
            File names will include any path prefixes. An empty list is returned
            if no files match ´name_filter´
        """
        files = self.get_detailed_file_list(storage_key, name_filter)
        names = [f['file_name'] for f in files]
        return names

    @abstractmethod
    def get_detailed_file_list(self, storage_key: str, name_filter: str = '*') -> List[dict]:
        """
        Get files stored in this storage key, with details as name and download url.

        Parameters
        ----------
        storage_key : str
            Unique identifier for a file storage location.
        name_filter : str, optional
            Provide a glob-style filter. The default is '*'.

        Returns
        -------
        List[dict('file_name':str, 'url':str)]
            File names will include any path prefixes. An empty list is returned
            if no files match ´name_filter´
        """
        return NotImplemented

    def get_scoped_file_list(self, storage_key: str, tag: str,
                             scope_indices: List[int]) -> List[str]:
        """
        Get list of filenames stored under *tag* as "seen" from *scope_indices*.

        Parameters
        ----------
        storage_key : str
            Unique identifier for a file storage location.
        tag : str
            File tag.
        scope_indices : Optional[List[int]], optional
            List of indices representing a scope. E.g. the scope of a duplicated task
            in a duplication hierarchy.

        Returns
        -------
        List[str]
            File names "seen" under the given *tag* from the scope of a duplicated task.
        """
        if not self._load_tags(storage_key)[tag] == '*SCOPED*' or not scope_indices:
            file_list = self.get_tags(storage_key)[tag]
            # file_list can either be str og list, ensure list:
            return file_list if isinstance(file_list, list) else [file_list]

        def is_in_scope(fname, scope_prefix):
            fname_prefix = PurePath(fname).parent.as_posix()
            if fname_prefix.startswith(scope_prefix):
                return True
            if scope_prefix.startswith(fname_prefix):
                return True
            return False

        scope_prefix = tag
        for scope_index in scope_indices:
            scope_prefix += '/' + str(scope_index)

        candidates = self.get_file_list(storage_key, tag + '/*')
        matched = []
        for c in candidates:
            if is_in_scope(c, scope_prefix):
                matched.append(c)
        return matched

    def get_prefixed_file_list(self,
                               storage_key: str,
                               tag: str,
                               scope_indices: Optional[List] = None) -> List[str]:

        scoped_file_list = self.get_scoped_file_list(
            storage_key,
            tag,
            scope_indices or [])

        prefixed_file_list = []
        for fname in scoped_file_list:
            p = PurePath(fname)
            scope_prefix = p.parent.as_posix()
            if scope_prefix == '.':
                prefixed_file_list.append(p.name)
            else:
                scope_prefixes = self._load_scope_prefixes(storage_key)
                filename_prefix = self._get_filename_prefix(scope_prefix, scope_indices)
                prefixed_file_list.append(filename_prefix + p.name)
        return prefixed_file_list

    @abstractmethod
    def upload(
            self,
            storage_key: str,
            filename: Union[str, Sequence[str]],
            path_prefix: str = '',
            tag: Optional[str] = None
    ) -> List[str]:
        """
        Upload file(s) to this storage resource with an optional path prefix.

        Parameters
        ----------
        storage_key : str
            Unique identifier for a file storage location.
        filename : Union[str, Sequence[str]]
            File(s) to upload.
        path_prefix : str, optional
            The file will be stored with a path prefix. The default is ''.
        tag : str, optional
            Provide a tag to the file(s) for easy referencing. Mandatory if
            *scope_indices* are specified.

        Returns
        -------
        List[str]
            Returns the uploaded file name(s) including path prefix.

        """
        return NotImplemented

    @abstractmethod
    def upload_scoped(
            self,
            storage_key: str,
            filename: Union[str, Sequence[str]],
            tag: str,
            scope_indices: List[int],
            path_prefix: str = ''
    ) -> List[str]:
        """
        Upload file(s) to this storage resource from scope.

        Parameters
        ----------
        storage_key : str
            Unique identifier for a file storage location.
        filename : Union[str, Sequence[str]]
            File(s) to upload.
        tag : str
            Provide a tag to the file(s) for easy referencing.
        scope_indices : Optional[List[int]]
            List of indices representing a scope. E.g. the scope of a
            duplicated task in a duplication hierarchy. I.e. only the files that
            are "seen" from the position of the duplicated task are downloaded.
        path_prefix : str, optional
            The file will be stored with a path prefix. The default is ''.

        Returns
        -------
        List[str]
            Returns the uploaded file name(s) including path prefix.

        """
        return NotImplemented

    @abstractmethod
    def download(
            self,
            storage_key: str,
            fname_or_tag: Union[str, Sequence[str]],
            target_dir: str = '.',
    ) -> List[str]:
        """
        Download file(s) from this storage resource.

        Parameters
        ----------
        storage_key : str
            Unique identifier for a file storage location.
        fname_or_tag : Union[str, Sequence[str]]
            File name or tag. file name(s) must include path prefixes
        target_dir : str, optional
            Local target directory. The default is '.'.

        Returns
        -------
        List[str]
            Returns the full local path(s) to downloaded file(s).
        """
        return NotImplemented

    @abstractmethod
    def download_scoped(
            self,
            storage_key: str,
            fname_or_tag: str,
            scope_indices: List[int],
            target_dir: str = '.'
    ) -> List[str]:
        """
        Download file(s) from this storage resource from scope.

        Parameters
        ----------
        storage_key : str
            Unique identifier for a file storage location.
        fname_or_tag : Union[str, Sequence[str]]
            File name or tag. file name(s) must include path prefixes
        scope_indices : Optional[List[int]], optional
            List of indices representing a scope for the caller. E.g. the position of a
            duplicated task in a duplication hierarchy. Then file(s) to download are
            determined from the scope of the duplicated task. I.e. only the files that
            are "seen" from the position of the duplicated task are downloaded.
        target_dir : str, optional
            Local target directory. The default is '.'.

        Returns
        -------
        List[str]
            Returns the full local path(s) to downloaded file(s).
        """
        return NotImplemented

    @abstractmethod
    def delete_all(self, storage_key: str) -> None:
        """
        Delete all files stored under this storage resource.

        Parameters
        ----------
        storage_key : str
            Unique identifier for a file storage location.
        """
        return NotImplemented
