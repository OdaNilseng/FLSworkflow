import datetime
import os
import time
from typing import Dict, Optional, List, Union

from fastapi import HTTPException
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from jose import jwt, jwk, JWTError
from jose.utils import base64url_decode
from pydantic import BaseModel
from starlette.requests import Request
from starlette.status import HTTP_403_FORBIDDEN

from rest.cognito.cognito_settings import CognitoSettings

JWK = Dict[str, str]


class JWKS(BaseModel):
    keys: List[JWK]


class JWTAuthorizationCredentials(BaseModel):
    jwt_token: str
    header: Dict[str, str]
    claims: Dict[str, Union[str, List[str]]]
    signature: str
    message: str


class JWTBearer(HTTPBearer):
    def __init__(self, jwks: JWKS, auto_error: bool = True):
        super().__init__(auto_error=auto_error)

        self.kid_to_jwk = {jwk["kid"]: jwk for jwk in jwks.keys}
        self.cognito_settings = CognitoSettings()

    def verify_jwk_token(self, jwt_credentials: JWTAuthorizationCredentials) -> (
            bool, str):
        # Perform the token validation steps as per
        # https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-tokens-with-identity-providers.html

        try:
            public_key = self.kid_to_jwk[jwt_credentials.header["kid"]]
        except KeyError:
            return (False, "JWK public key not found")

        key = jwk.construct(public_key)
        decoded_signature = base64url_decode(jwt_credentials.signature.encode())

        valid_signature = key.verify(jwt_credentials.message.encode(),
                                     decoded_signature)

        # Check iss claim
        claims = jwt_credentials.claims
        expected_issuer = self.cognito_settings.idp_url

        if claims["iss"] != expected_issuer:
            return (False, f"Invalid issuer in token: {claims['iss']}")

        expected_audience = self.cognito_settings.client_id
        if claims["client_id"] != expected_audience:
            return (False, f"Invalid audience in token: {claims['client_id']}")

        # Check token use
        # Should we only allow one of the tokens or both "id" and "access"?
        if claims["token_use"] not in ["id", "access"]:
            return (False, f"Token not of valid use: {claims['token_use']}")

        # Check exp and make sure it is not expired
        exp = int(claims["exp"])
        exp_date = datetime.datetime.utcfromtimestamp(exp)
        now = datetime.datetime.utcnow()
        if exp_date < now and os.environ.get("VALIDATE_EXPIRATION") != "false":
            return (False, "Token has expired {}".format(exp_date - now))

        return (valid_signature, "signature verification")

    def __create_mocked_credentials(self) -> JWTAuthorizationCredentials:
        header = {'kid': 'Q41jspM8qeYDX7qKlOFRmBIhjj5DdYAffZXUGUtbL24=',
                  'alg': 'RS256'}

        auth_time = int(time.time()) - 20 * 60
        iat = auth_time + 1234
        exp = iat + 60 * 60
        claims = {'sub': '9a901faf-7aa9-405a-9a80-8aa9e9e84c45',
                  'cognito:groups': ['developers'],
                  'token_use': 'access',
                  'scope': 'aws.cognito.signin.user.admin phone openid profile email',
                  'auth_time': auth_time,
                  'iss': 'https://cognito-idp.eu-west-1.amazonaws.com/eu-west-1_8jX4uBrFJ',
                  'exp': exp, 'iat': iat, 'version': 2,
                  'jti': 'a7dd5c89-52b0-49cd-a1fe-7a785de84db8',
                  'client_id': '733uhptdla4rug13f03jnagj7o',
                  'username': 'perhenden'}
        jwt_token = "eyJraWQiOiJRNDFqc3BNOHFlWURYN3FLbE9GUm1CSWhqajVEZFlBZmZaWFVHVXRiTDI0PSIsImFsZyI6IlJTMjU2In0.eyJzdWIiOiI5YTkwMWZhZi03YWE5LTQwNWEtOWE4MC04YWE5ZTllODRjNDUiLCJjb2duaXRvOmdyb3VwcyI6WyJkZXZlbG9wZXJzIl0sInRva2VuX3VzZSI6ImFjY2VzcyIsInNjb3BlIjoiYXdzLmNvZ25pdG8uc2lnbmluLnVzZXIuYWRtaW4gcGhvbmUgb3BlbmlkIHByb2ZpbGUgZW1haWwiLCJhdXRoX3RpbWUiOjE1OTMwNzc5ODksImlzcyI6Imh0dHBzOlwvXC9jb2duaXRvLWlkcC5ldS13ZXN0LTEuYW1hem9uYXdzLmNvbVwvZXUtd2VzdC0xXzhqWDR1QnJGSiIsImV4cCI6MTU5MzA4MTU4OSwiaWF0IjoxNTkzMDc3OTg5LCJ2ZXJzaW9uIjoyLCJqdGkiOiJhN2RkNWM4OS01MmIwLTQ5Y2QtYTFmZS03YTc4NWRlODRkYjgiLCJjbGllbnRfaWQiOiI3MzN1aHB0ZGxhNHJ1ZzEzZjAzam5hZ2o3byIsInVzZXJuYW1lIjoicGVyaGVuZGVuIn0.McmIHnJ6AlW8hFpNX1kZL5ctm0wfElnwpUKHCg-P3pOFdTCm-7YolX5RSljXRkXANFco0lRcBY_HRFHvnyY_8v_VUFoQBgp1FsPKLELLRlgeG2FaDsIQ_63_GD-Nk7tUw8v_lBSrME8r1wpt-xkfvkBSmi0b8fi9cRiWOfFM_6KvOOJR9uhpoa8sNWpzv65bp03q4IWOcGklxvg71Qb0xZqHUm3pxXzfBtWsEyiP_OugfRPid_dw04jhi0YfmgHgkVLWVnrtpxxSXcg6JJ7OfF9YBA_uRfYl4lzobirfjFEk917d0G6GZw5wqSd3raz503I6McJTX1hyPmSSgb7swA"
        message = "eyJraWQiOiJRNDFqc3BNOHFlWURYN3FLbE9GUm1CSWhqajVEZFlBZmZaWFVHVXRiTDI0PSIsImFsZyI6IlJTMjU2In0.eyJzdWIiOiI5YTkwMWZhZi03YWE5LTQwNWEtOWE4MC04YWE5ZTllODRjNDUiLCJjb2duaXRvOmdyb3VwcyI6WyJkZXZlbG9wZXJzIl0sInRva2VuX3VzZSI6ImFjY2VzcyIsInNjb3BlIjoiYXdzLmNvZ25pdG8uc2lnbmluLnVzZXIuYWRtaW4gcGhvbmUgb3BlbmlkIHByb2ZpbGUgZW1haWwiLCJhdXRoX3RpbWUiOjE1OTMwNzc5ODksImlzcyI6Imh0dHBzOlwvXC9jb2duaXRvLWlkcC5ldS13ZXN0LTEuYW1hem9uYXdzLmNvbVwvZXUtd2VzdC0xXzhqWDR1QnJGSiIsImV4cCI6MTU5MzA4MTU4OSwiaWF0IjoxNTkzMDc3OTg5LCJ2ZXJzaW9uIjoyLCJqdGkiOiJhN2RkNWM4OS01MmIwLTQ5Y2QtYTFmZS03YTc4NWRlODRkYjgiLCJjbGllbnRfaWQiOiI3MzN1aHB0ZGxhNHJ1ZzEzZjAzam5hZ2o3byIsInVzZXJuYW1lIjoicGVyaGVuZGVuIn0"
        signature = "McmIHnJ6AlW8hFpNX1kZL5ctm0wfElnwpUKHCg-P3pOFdTCm-7YolX5RSljXRkXANFco0lRcBY_HRFHvnyY_8v_VUFoQBgp1FsPKLELLRlgeG2FaDsIQ_63_GD-Nk7tUw8v_lBSrME8r1wpt-xkfvkBSmi0b8fi9cRiWOfFM_6KvOOJR9uhpoa8sNWpzv65bp03q4IWOcGklxvg71Qb0xZqHUm3pxXzfBtWsEyiP_OugfRPid_dw04jhi0YfmgHgkVLWVnrtpxxSXcg6JJ7OfF9YBA_uRfYl4lzobirfjFEk917d0G6GZw5wqSd3raz503I6McJTX1hyPmSSgb7swA"

        return JWTAuthorizationCredentials(
            jwt_token=jwt_token,
            header=header,
            claims=claims,
            signature=signature,
            message=message,
        )

    async def __call__(self, request: Request) -> Optional[JWTAuthorizationCredentials]:
        if os.environ.get("MOCKED_CREDENTIALS") == "true":
            print("Returning mocked credentials")
            return self.__create_mocked_credentials()

        credentials: HTTPAuthorizationCredentials = await super().__call__(request)

        if credentials:
            if not credentials.scheme == "Bearer":
                raise HTTPException(
                    status_code=HTTP_403_FORBIDDEN, detail="Wrong authentication method"
                )

            jwt_token = credentials.credentials

            message, signature = jwt_token.rsplit(".", 1)

            try:

                header = jwt.get_unverified_header(jwt_token)
                claims = jwt.get_unverified_claims(jwt_token)

                jwt_credentials = JWTAuthorizationCredentials(
                    jwt_token=jwt_token,
                    header=header,
                    claims=claims,
                    signature=signature,
                    message=message,
                )
            except JWTError:
                raise HTTPException(status_code=HTTP_403_FORBIDDEN,
                                    detail="JWK invalid")

            (verify_result, verify_message) = self.verify_jwk_token(jwt_credentials)
            if not verify_result:
                raise HTTPException(status_code=HTTP_403_FORBIDDEN,
                                    detail=verify_message)

            return jwt_credentials
